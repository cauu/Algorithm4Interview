***
###0-ZigZag Conversion  

***  
给定一个string，对其做zigzag映射，并输出映射后的string。如:
  
```
convert("PAYPALISHIRING", 3)
```
to

```
P   A   H   N
A P L S I I G
Y   I   R
以字符串的形式输出，得到
PAHNAPLSIIGYIR
```
  
###解决思路
  
***
说实话，我并不太理解题目的描述，看了论坛里面的解答之后，大家可以把zigzag conversion理解成一种固定的映射关系，这样只要使用公式把字符串中的字符映射到正确的位置，就可以得到结果了。

###1-Valid Palindrome 

***  
忽略符号和字母大小写，判断一个给定的字符串是否是回文(palindrome)。  
首先解释一下什么是“回文”。如果一个string无论是正着读，还是倒着读，结果都相同，那么它就是一段回文。  
如```aaabbbaaa```就是一段回文。

  
###解决思路
  
***
从头和尾同时开始遍历一个string，若str[head]!=str[tail]那么该string就不是回文。  
  
###2-Palindrome Linked List

***  
判断一个单向链表是否是回文。

  
###解决思路
  
***
同1。  
另一种解法：使用两个指针，fast和slow，fast的移动速度是slow的两倍，因此当fast到达结尾时，slow刚好到达链表中间。此时我们将剩余的链表反转(reverse)，分别从头尾开始遍历链表，若头尾结点的值不想等，则该链表不是回文。

###3-Palindrome Number

***  
判断一个整数是否是回文。（不要使用额外空间）
这道题有几个坑需要特别注意:  
1. 负数是否是回文？（此处默认所有负数都不是回文）
2. 如果允许使用额外空间，那么将number直接转换成一个string是更加简单的思路。
3. 可以将整数反转，然而反转后的整数可能会溢出。
  
###解决思路
  
***
比较general的解决方法，首先获取整数的位数，然后从头、尾分别遍历该整数即可。

###4-Add Binary

***  
给两个二进制表示的数组，对其求和。如: 

```
a = "11"
b = "1"
Return "100".
```
  
###解决思路
  
***
使用一个额外的carry保存对应位上的数字想加后是否有进位。

###5-Compare Version Numbers

***  
比较两个版本号的大小，有一些坑，如:  
  
```
0.1 < 1.1 === 1.01 < 1.2 < 1.010 < 1.00100 < 11.1 < 11.1.1
```
  
###解决思路
  
***
主要是一开始想的太多，实际上小数点后面的数字前面0的数量和版本大小没有关系，只需要单纯的将其转换成int就行。

###思考

***
如果将小数考虑进去，版本号应该如何比较？