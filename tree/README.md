###0-Invert Binary Tree
  
***
####问题：
  
将一个二叉树左右翻转。  
如:
  
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
to  
   
```
    4
   /   \
  7     2
 / \   / \
9   6 3   1
```
  
####解决思路
  
***
很基本的一个问题，采用递归的思路，首先将根节点的左右结点调换，再分别将左右结点的子节点调换。
  
###1-Max Depth of Binary Tree

***
####问题: 
求一个二叉树的最大深度。 
  
如:
  
```
    4
   /   \
  7     2
 / \   
9   6 
maxDepth=3;
``` 
  
####解决思路
  
***
递归。分别遍历二叉树的左子树和右子树，若左子树深
度大于右子树，则返回左子树深度+1（当前结点）。
  
###2-Min Depth of Binary Tree

***
####问题: 
求一个二叉树到叶子结点的最小深度。 
  
如:
  
```
    4
   /   \
  7     2
 / \   
9   6 
minDepth=2;
``` 
  
####解决思路
  
***
这道题和前一题看似相似，实际上埋了一个小小的坑：若一个结点只有左子树，形如: 

```
    4
   /   
  7     
```
当我们求其最小深度时，因其右子树深度为0，我们很容易就把它当成当前的最小深度。然而，题目中定义的最小深度是<font style="color:red">二叉树到叶子结点的最小深度</font>，因为该结点存在左子树，所以它并不是一个叶子结点。正确的答案是1。

###3-Binary Tree Level Order Traversal

***
####问题: 
以广度优先的遍历方式，输出二叉树的值。
  
如:
  
```
    3
   / \
  9  20
    /  \
   15   7
return:
[
  [3],
  [9,20],
  [15,7]
]
``` 
  
####解决思路
  
***
广度优先遍历二叉树。无论是深度优先遍历，还是广度优先遍历，它们解决的思路都是很类似的：用栈/队列储存二叉树的结点，当访问完该结点后，将其子结点push到栈/队列中，然后删除该结点。  
  
Reference:  
[二叉树的深度优先和广度优先遍历](http://www.cnblogs.com/lscheng/archive/2013/09/11/3313947.html¡)
  
###4-Path Sum

***
####问题:   
  
给定一个sum，判断二叉树中是否存在一条从根节点到叶子结点的路径，使得路径上所有数字之和等于sum。  

如给定sum=22，下图: 
     
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
存在5-4-11-2这条路径和为22，返回true
```

####解决思路
  
***
可以通过简单的递归实现。最终，若sum减去当前结点的值等于0，且sum是叶子结点，那么返回true，否则递归。（单纯的实现很简单，但更重要的是考虑一些特殊条件，对递归进行优化）
  
###5-Path Sum 2

***
####问题:   
  
给定一个sum，判断二叉树中是否存在一条从根节点到叶子结点的路径，使得路径上所有数字之和等于sum，并且输出所有匹配的路径  

如给定sum=22，下图: 
     
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
存在5-4-11-2这条路径和为22，
输出结果为:
[
	[5,4,11,2]
]
```

####解决思路
  
***
这道题目的关键是在上一题的基础上遍历二叉树的同时，还要保存当前结点的信息，以便能将结果正确输出。由于我希望通过递归来解决这一问题，因此很重要的一点是使用一个外部数组来保存递归的状态。

###6-Binary Tree Paths 

***
####问题:   
  
输出二叉树中所有从叶节点到根节点的路径。

     
```
   1
 /   \
2     3
 \
  5

```

结果为

```
["1->2->5", "1->3"]

```

####解决思路
  
***
同5。

###7-Flatten Binary Tree to Linked List 

***
####问题:   
  
给定一个二叉树，将其转换成一个链表。
如:  
     
```
         1
        / \
       2   5
      / \   \
     3   4   6

```
结果为

```
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6

```

####解决思路
  
***
使用递归的思路很简单：首先将其左子树转换为链表，再将其右子树转换为链表，最后将右子树添加到左子树叶子节点的right上，然后把左子树转换成根节点的右子树即可。

###8-Binary Tree Level Order Traversal II

***
####问题: 
同3，只是输出的结果由正序改为倒序。
  
####解决思路
  
***
同3。

###9-Symmetric Tree

***
####问题: 
判断一个二叉树是否是对称的二叉树。  
如:  

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
是对称的二叉树
    1
   / \
  2   2
   \   \
   3    3
是非对称二叉树
```
  
####解决思路
  
***
若根节点的左右子树的值相等，对比其左子树的左子树的值和其右子树右子树的值，右子树的左子树和左子树的右子树的值。
  
###10-Sum Root to Leaf Numbers

***
####问题: 
求出所有到叶子结点的路径所代表的数字之和。 
如:  

```
    1
   / \
  2   3
```
存在两条路径```1->2, 2->3```， 其代表的数字是12,13，最后返回的结果为```12+13 = 25```
  
####解决思路
  
***
深度优先遍历数，若遇到叶子结点，则返回结果。

###11-Binary Search Tree Iterator

***
####问题: 
实现[二叉查找树](http://www.cnblogs.com/huangxincheng/archive/2012/07/21/2602375.html)的迭代器，使得next能返回二叉树中下一个最小值，hasNext能够判断二叉树是否还有剩余结点。
要求next和hasNext实现O(h)(h是层高)的空间复杂度和O(1)的时间复杂度。
  
####解决思路
  
***
要实现O(1)的时间复杂度，就要求使用数组来储存二叉树的结点。我们只需要对二叉树采用中序遍历（left->root->right）的方式，就可以得到一个按节点值从小到大排列的数组。

###12-Binary Tree Inorder Traversal

***
####问题: 
使用非递归的方式实现二叉树的中序遍历。
  
####解决思路
  
***
使用递归解决这个问题的实现自不必说。  
之前实现的二叉树的深度优先和广度优先的遍历方式给了我启发：两者分别使用栈和队列对二叉树进行了遍历。因此，这道题，采用了类似的解法：使用一个栈来储存我们遍历过的结点，按照```右子树--->根结点--->左子树```的顺序依次将树的结点压栈，之后pop出栈顶的结点，若该结点不存在子树，将其输出；若存在子树，将其按照刚才的顺序重新压栈，并为其添加一个visited标识符，直到栈的长度为0，停止循环。