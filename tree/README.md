###0-Invert Binary Tree
  
***
####问题：
  
将一个二叉树左右翻转。  
如:
  
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
to  
   
```
    4
   /   \
  7     2
 / \   / \
9   6 3   1
```
  
####解决思路
  
***
很基本的一个问题，采用递归的思路，首先将根节点的左右结点调换，再分别将左右结点的子节点调换。
  
###1-Max Depth of Binary Tree

***
####问题: 
求一个二叉树的最大深度。 
  
如:
  
```
    4
   /   \
  7     2
 / \   
9   6 
maxDepth=3;
``` 
  
####解决思路
  
***
递归。分别遍历二叉树的左子树和右子树，若左子树深
度大于右子树，则返回左子树深度+1（当前结点）。
  
###2-Min Depth of Binary Tree

***
####问题: 
求一个二叉树到叶子结点的最小深度。 
  
如:
  
```
    4
   /   \
  7     2
 / \   
9   6 
minDepth=2;
``` 
  
####解决思路
  
***
这道题和前一题看似相似，实际上埋了一个小小的坑：若一个结点只有左子树，形如: 

```
    4
   /   
  7     
```
当我们求其最小深度时，因其右子树深度为0，我们很容易就把它当成当前的最小深度。然而，题目中定义的最小深度是<font style="color:red">二叉树到叶子结点的最小深度</font>，因为该结点存在左子树，所以它并不是一个叶子结点。正确的答案是1。

###3-Binary Tree Level Order Traversal

***
####问题: 
以广度优先的遍历方式，输出二叉树的值。
  
如:
  
```
    3
   / \
  9  20
    /  \
   15   7
return:
[
  [3],
  [9,20],
  [15,7]
]
``` 
  
####解决思路
  
***
广度优先遍历二叉树。无论是深度优先遍历，还是广度优先遍历，它们解决的思路都是很类似的：用栈/队列储存二叉树的结点，当访问完该结点后，将其子结点push到栈/队列中，然后删除该结点。  
  
Reference:  
[二叉树的深度优先和广度优先遍历](http://www.cnblogs.com/lscheng/archive/2013/09/11/3313947.html¡)
  
