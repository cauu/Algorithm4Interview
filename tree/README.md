###0-Invert Binary Tree
  
***
####问题：
  
将一个二叉树左右翻转。  
如:
  
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
to  
   
```
    4
   /   \
  7     2
 / \   / \
9   6 3   1
```
  
####解决思路
  
***
很基本的一个问题，采用递归的思路，首先将根节点的左右结点调换，再分别将左右结点的子节点调换。
  
###1-Max Depth of Binary Tree

***
####问题: 
求一个二叉树的最大深度。 
  
如:
  
```
    4
   /   \
  7     2
 / \   
9   6 
maxDepth=3;
``` 
  
####解决思路
  
***
递归。分别遍历二叉树的左子树和右子树，若左子树深
度大于右子树，则返回左子树深度+1（当前结点）。
  
###2-Min Depth of Binary Tree

***
####问题: 
求一个二叉树到叶子结点的最小深度。 
  
如:
  
```
    4
   /   \
  7     2
 / \   
9   6 
minDepth=2;
``` 
  
####解决思路
  
***
这道题和前一题看似相似，实际上埋了一个小小的坑：若一个结点只有左子树，形如: 

```
    4
   /   
  7     
```
当我们求其最小深度时，因其右子树深度为0，我们很容易就把它当成当前的最小深度。然而，题目中定义的最小深度是<font style="color:red">二叉树到叶子结点的最小深度</font>，因为该结点存在左子树，所以它并不是一个叶子结点。正确的答案是1。

###3-Binary Tree Level Order Traversal

***
####问题: 
以广度优先的遍历方式，输出二叉树的值。
  
如:
  
```
    3
   / \
  9  20
    /  \
   15   7
return:
[
  [3],
  [9,20],
  [15,7]
]
``` 
  
####解决思路
  
***
广度优先遍历二叉树。无论是深度优先遍历，还是广度优先遍历，它们解决的思路都是很类似的：用栈/队列储存二叉树的结点，当访问完该结点后，将其子结点push到栈/队列中，然后删除该结点。  
  
Reference:  
[二叉树的深度优先和广度优先遍历](http://www.cnblogs.com/lscheng/archive/2013/09/11/3313947.html¡)
  
###4-Path Sum

***
####问题:   
  
给定一个sum，判断二叉树中是否存在一条从根节点到叶子结点的路径，使得路径上所有数字之和等于sum。  

如给定sum=22，下图: 
     
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
存在5-4-11-2这条路径和为22，返回true
```

####解决思路
  
***
可以通过简单的递归实现。最终，若sum减去当前结点的值等于0，且sum是叶子结点，那么返回true，否则递归。（单纯的实现很简单，但更重要的是考虑一些特殊条件，对递归进行优化）
  
###5-Path Sum 2

***
####问题:   
  
给定一个sum，判断二叉树中是否存在一条从根节点到叶子结点的路径，使得路径上所有数字之和等于sum，并且输出所有匹配的路径  

如给定sum=22，下图: 
     
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
存在5-4-11-2这条路径和为22，
输出结果为:
[
	[5,4,11,2]
]
```

####解决思路
  
***
这道题目的关键是在上一题的基础上遍历二叉树的同时，还要保存当前结点的信息，以便能将结果正确输出。由于我希望通过递归来解决这一问题，因此很重要的一点是使用一个外部数组来保存递归的状态。